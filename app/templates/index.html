<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />

        <script>
            L_NO_TOUCH = false;
            L_DISABLE_3D = false;
        </script>

        <style>
            html,
            body {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
        </style>
        <style>
            #map {
                position: absolute;
                top: 0;
                bottom: 0;
                right: 0;
                left: 0;
            }
        </style>

        <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"
        />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
        />
        <link
            rel="stylesheet"
            href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css"
        />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css"
        />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"
        />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"
        />

        <meta
            name="viewport"
            content="width=device-width,
                initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
        <style>
            #map_inner {
                position: relative;
                width: 100%;
                height: 100%;
                left: 0%;
                top: 0%;
            }
            .folium-map {
                flex: 1;
                margin-left: 160px; /* Adjust based on the sidebar width */
                height: 100vh; /* Take full height of the viewport */
            }
            .leaflet-container {
                font-size: 1rem;
            }
        </style>
        <!-- include css file -->
        <link rel="stylesheet" href="../static/css/sidebar.css" />

        <script src="https://cdn.jsdelivr.net/gh/python-visualization/folium@main/folium/templates/leaflet_heat.min.js"></script>
    </head>
    <body>
        <div class="folium-map" id="map_inner"></div>

        <div class="sidenav">
            <button id="publicBtn" class="active">Public</button>
            <button id="fourYearsBtn" class="active">4 Years</button>
            <button id="inStateBtn" class="active">In State</button>
        </div>
    </body>

    <script>
        // Initial state of variables
        var is_public = true;
        var is_4yrs = true;
        var is_in_state = true;
        var heat_map;
        var dot_map;

        // JavaScript to handle toggle functionality
        document.addEventListener("DOMContentLoaded", function () {
            var publicBtn = document.getElementById("publicBtn");
            var fourYearsBtn = document.getElementById("fourYearsBtn");
            var inStateBtn = document.getElementById("inStateBtn");

            // Add click event listeners to the buttons
            publicBtn.addEventListener("click", function () {
                is_public = !is_public;
                toggleButton(publicBtn, is_public);
            });

            fourYearsBtn.addEventListener("click", function () {
                is_4yrs = !is_4yrs;
                toggleButton(fourYearsBtn, is_4yrs);
            });

            inStateBtn.addEventListener("click", function () {
                is_in_state = !is_in_state;
                toggleButton(inStateBtn, is_in_state);
            });

            function toggleButton(button, state) {
                button.classList.toggle("active", state);
                updateHeatmap();
            }
        });

        // Generate the map
        colleges = `{{ colleges|tojson|safe }}`;

        var colleges = JSON.parse(colleges);

        var map_inner = L.map("map_inner", {
            center: [37.7749, -95.4194],
            crs: L.CRS.EPSG3857,
            zoom: 4,
            zoomControl: true,
            preferCanvas: false,
        });

        var tile_layer = L.tileLayer(
            "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
            {
                attribution:
                    '\u0026copy; \u003ca href="https://www.openstreetmap.org/copyright"\u003eOpenStreetMap\u003c/a\u003e contributors',
                detectRetina: false,
                maxNativeZoom: 19,
                maxZoom: 19,
                minZoom: 0,
                noWrap: false,
                opacity: 1,
                subdomains: "abc",
                tms: false,
            }
        );

        tile_layer.addTo(map_inner);

        // Function to update the heatmap
        function updateHeatmap() {
            // Filter the data based on button states
            var filteredData = colleges.map((college) => {
                if (is_public) {
                    if (college["school_type"] !== 1) return null;
                } else {
                    if (college["school_type"] === 1) return null;
                }

                if (is_4yrs) {
                    if (college["degree_length"] <= 2) return null;
                } else {
                    if (college["degree_length"] > 2) return null;
                }

                // Check if all three values are not null
                if (
                    college["latitude"] !== null &&
                    college["longitude"] !== null
                ) {
                    var tuitionValue = is_in_state
                        ? college["tuition_in_state"]
                        : college["tuition_out_of_state"];

                    // Check if tuitionValue is not null
                    if (tuitionValue !== null) {
                        return [
                            college["latitude"],
                            college["longitude"],
                            tuitionValue,
                            college["school_name"],
                        ];
                    }
                }

                // If any of the values is null, skip this entry
                return null;
            });

            // Remove entries with null values
            filteredData = filteredData.filter((entry) => entry !== null);

            // Remove the existing dotmap layer
            if (dot_map) {
                map_inner.removeLayer(dot_map);
            }

            // Now, find the min and max tuition values
            const tuitionValues = filteredData.map(entry => entry[2]);
            const minTuition = Math.min(...tuitionValues);
            const maxTuition = Math.max(...tuitionValues);

            // Divide the range into five segments
            const segmentSize = (maxTuition - minTuition) / 5;

            // Create a 2D array with five rows based on tuition segments
            const segmentedArray = Array.from({ length: 5 }, (_, i) => {
                const minSegment = minTuition + i * segmentSize;
                const maxSegment = minTuition + (i + 1) * segmentSize;
                
                return filteredData.filter(entry => entry[2] >= minSegment && entry[2] < maxSegment);
            });


            // Remove the existing heatmap layers
            for (let i = 1; i <= 5; i++) {
                const heatMapVariable = window[`heat_map${i}`];
                if (heatMapVariable) {
                    map_inner.removeLayer(heatMapVariable);
                }
            }

            // Create heatmap layers for each segment
            for (let i = 0; i < 5; i++) {
                const color = getColorForSegment(i); // You should define getColorForSegment function to return color based on the segment
                window[`heat_map${i + 1}`] = L.heatLayer(segmentedArray[i], {
                    //blur: 50,
                    color: color,
                    maxZoom: 18,
                    //minOpacity: 0.5,
                    radius: 20,
                });
                map_inner.addLayer(window[`heat_map${i + 1}`]);
            }

            // Example function to define color based on segment
            function getColorForSegment(segment) {
                // Define your color logic based on the segment index
                const colors = ["green", "yellow", "orange", "red", "purple"];
                return colors[segment];
            }

            dot_map = L.layerGroup(
                filteredData.map((entry) => {
                    return L.circleMarker([entry[0], entry[1]], {
                        radius: 2,
                        fillColor: "white",
                        color: "black",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 1,
                    }).bindPopup(
                        `<b>${entry[3]}</b><br>
                        Tuituion: $${entry[2]}<br>
                        `
                    );
                })
            );

            // Add the new heatmap layer to the map
            map_inner.addLayer(dot_map);
            heat_map.addTo(map_inner);
        }

        // Call updateHeatmap to show the heatmap initially
        updateHeatmap();

        function normalization(x) {
            return Math.exp(100 * (x / 10000)) - 1;
        }
    </script>
</html>
